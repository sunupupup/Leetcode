
-- 左连接这种，如果有不存在的值，就会被赋值为null
select e.last_name,e.first_name,d.dept_no
from employees e left join dept_emp d       -- left outer join dept_emp d
on e.emp_no=d.emp_no

/*
内联结，两边表同时有对应的数据，即任何一边缺失数据就不显示。
左联结，读取左边数据表的全部数据，即便右边表无对应数。即右表d中dept_no即使为NULL，也会读取左表e中的全部emp。
*/

/*
原则是小表驱动大表，
当使用left join时，左表是驱动表，右表是被驱动表，
当使用right join时，右表时驱动表，左表是被驱动表，
当使用inner join时，mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表

根据实际场景考虑的话：要所有的数据，那肯定大表驱动小表
一般情况下，大表中查小表的数据，就是小表在前驱动大表



 (这题目改成100万和10000万比较好，这才算是大表) 如果是考察语句写法，这两个表谁放前面都一样，优化器会调整顺序选择合适的驱动表；

如果是考察优化器怎么实现的，你可以这么想，每次在树搜索里面做一次查找都是log(n), 所以对比的是100log(10000)和
10000log(100)哪个小，显然是前者，所以结论应该是让小表驱动大表。

*/